# Core Module: Data Structures & Parsing

Этот модуль содержит ключевые структуры данных, живущие в L1 кэше.

## L2OrderBook (`orderbook.rs`)

`L2OrderBook` реализует биржевой стакан с фиксированной глубиной (20 уровней).

### Memory Layout

Используется `#[repr(C, align(64))]` для выравнивания структуры по линии кэша (Cache Line) современных процессоров (обычно 64 байта).
Это предотвращает false sharing между потоками (хотя в нашей архитектуре доступ к ней имеет только Hot Thread, выравнивание полезно для SIMD и предсказуемости).

*   **Bids:** Массив `[Level; 20]` (20 * 16 байт = 320 байт)
*   **Asks:** Массив `[Level; 20]` (20 * 16 байт = 320 байт)
*   **Total Size:** 640 байт. Это легко помещается в L1d Cache (обычно 32KB или 48KB).

Мы **НЕ** используем `Vec` или динамические списки. Обновление стакана (вставка/удаление) происходит за O(N), где N=20. Для таких малых N линейный проход по массиву в L1 кэше выполняется быстрее, чем логарифмический поиск по сложному дереву (B-Tree/HashMap), которое вызывает промахи кэша (cache misses).

## Parser (`parser.rs`)

Мы используем крейт `simd-json` для парсинга JSON сообщений.

*   **Zero-Copy:** Парсер работает непосредственно с входящим буфером байтов (`&mut [u8]`), изменяя его "in-place".
*   **Direct Update:** Мы не десериализуем JSON в промежуточные Rust-структуры. Мы "гуляем" по ленте токенов (Tape), извлекаем поля `p` (price) и `q` (qty) и сразу обновляем `L2OrderBook`. Это исключает аллокации (heap allocation) на этапе обработки маркет-даты.
